# 1. 考试内容

![](软件设计师笔记_files/154.jpg)

- 上午 选择题 1分一题；
- 下午 问答题：数据流题、数据库题、UML、面像对象、算法C语言

![](软件设计师笔记_files/155.jpg)

## 1.1 历年考试情况分析
![](软件设计师笔记_files/156.jpg)

![](软件设计师笔记_files/157.jpg)

# 2. 数据表示

- **浮点数的阶码**是指用科学计数法表示浮点数时，**指数部分的值**；

- 二进制**补码**编码是现代计算机中最常用的数字编码，也是**最适合数字加减运算**的编码方式；

- **浮点数的阶码**通常使用**移码（biased）**表示，也称为偏移码或者指数偏置；
	
	```
	// 这个偏移值通常是 2^(k-1)-1（k 是阶码所占的位数）
	// 对于一个浮点数，其阶码的移码表示可以通过以下公式计算出来：
	**移码 = 阶码 + 偏移量**
	```
	
- **寻址**的过程包括两个步骤：首先根据地址寻址方式得到数据的地址，然后从内存或寄存器中读取或写入数据;

- 指令系统中采用**不同寻址方式**的目的主要是**扩大寻址空间**并提高编程灵活性；

## 2.1 R进制转十进制（按权展开法）

![image-20230414090848095](/软件设计师笔记_files/image-20230414090848095.png)

## 2.2 十进制转 R进制（短除法）

![image-20230414091508578](/软件设计师笔记_files\image-20230414091508578.png)

## 2.3  二进制转 八进制与十六进制（划分3和4位进行按权展开计算）

- 比如二进制转十六进制： 1000 = 2^3+0x2^2+0x2^1+0x2^0 = 8;

![image-20230414093918918](/软件设计师笔记_files\image-20230414093918918.png)

## 2.4 原码、反码、补码、移码

- **符号位**为左边的第一位，正数的为0 ，负数为1；
- **正数** 原码、反码、补码一致；
- **负数**的**反码**为 **符号位不变**以原码其他位 **取反**，**补码**是反码加1位。
- **移码**是补码的符号位取反，其他位不变。

![image-20230414094249204](/软件设计师笔记_files\image-20230414094249204.png)

## 2.5 原码、反码、补码取值范围

- 比如 n = 8，2^7=128 ; 原码与反码表示： -127 至 127 (因为有**正负0都表示不同的编码**所以各减1)；
- **补码**表示：-128至127；（因为正0 和负0 都是8个0，所以**少占用一个编码**）;

![image-20230414095639304](/软件设计师笔记_files\image-20230414095639304.png)

## 2.6 浮点数运算

- 对阶表示： 相同指数；
- 尾数计算：比如1x10^3 和1.119x10^2进行计算，转化为1x10^3 和 0.119x10^3进行计算；
- 结果格式化：保证尾数的值只能是个位且不能为0
- 对阶时，小数向大数看齐；对阶是通过较小数的尾数右移实现的；

![image-20230414113117803](/软件设计师笔记_files\image-20230414113117803.png)

# 3.计算机组成与体系结构

## 3.1 计算结构

- CPU 包含：运算器和控制器
- 运算器：算术逻辑单元ALU 、累加寄存器AC、数据缓冲寄存器DR、状态条件寄存器PSW;
  1. 算术逻辑单元（Arithmetic Logic Unit，简称ALU）它负责执行算术和逻辑操作；
  2. 累加寄存器（Accumulator Register，简称AC），用于存储和累加运算结果；
  3. 数据缓冲寄存器（Data Buffer Register，简称DR）是一种在计算机中用于暂时存储数据的寄存器;
  4. 状态条件寄存器（Status Condition Register，简称CCR）是一种用于保存计算机处理器运行状态的寄存器；
- 控制器：程序计数器PC、指令寄存器IR、指令译码器、时序部件；
  	1. 程序计数器（Program Counter，PC）是一种寄存器，用于存储CPU**当前执行的指令的内存地址**。它在CPU执行指令时不断更新，**指向下一条要执行的指令的内存地址**; CPU首先从程序计数器（PC）获得需要执行的指令地址，从内存（或高速缓存）读取到的指令则暂存在指令寄存器（IR），然后进行分析和执行；
   	2. 指令寄存器（Instruction Register，IR）是一种寄存器，用于存储当前CPU正在执行的指令，当程序计数器PC指向下一条指令的内存地址时，指令寄存器IR会将该**指令从内存中取出**并保存在其中，以便**CPU能够解码和执行该指令**；
   	3. 指令译码器（Instruction Decoder）是CPU中的一种模块，负责解析指令寄存器IR中存储的二进制指令，并将其转换为CPU能够理解和执行的控制信号，用于将**不同的指令编码映射**到相应的**操作控制信号**；
   	4. 时序部件（Timing Control Unit）是CPU中的一个模块，负责控制和调节CPU内部各个组成部分之间的**时序关系**。它通常包括计时器、时钟发生器等模块，可以**确保指令和数据在正确的时间被读取和写入寄存器、缓存和内存**中，以及确保各个部件之间协同工作的顺序和时间关系符合CPU设计要求;

![image-20230414113729781](/软件设计师笔记_files\image-20230414113729781.png)

## 3.3 计算机体系结构分类 Flynn

![image-20230414124156941](/软件设计师笔记_files\image-20230414124156941.png)

## 3.4 CISC 与 RISC
- CISC代表复杂指令集计算机（Complex Instruction Set Computer），是一种计算机处理器架构的类型，其指令集非常丰富和复杂。CISC处理器通常具有**高度优化的指令集**，这些指令可以在单个指令中**执行多个低级操作**，从而提高了处理器的效率和性能。然而，由于指令集的复杂性，CISC处理器的设计和实现成本较高，且难以实现高性能的并行处理；
- RISC代表精简指令集计算机（Reduced Instruction Set Computer），是一种计算机处理器架构的类型，其指令集相对较少和简单。RISC处理器通常执行基本指令，每个指令只**执行一个低级操作**，并**使用流水线技术来实现高性能并行处理**。由于其指令集简单，RISC处理器的设计和实现成本相对较低，且易于实现高性能的并行处理。近年来，大多数计算机处理器都采用了RISC设计，例如ARM和PowerPC；

![image-20230414175725994](/软件设计师笔记_files\image-20230414175725994.png)

## 3.5 流水线

- 坐标中格子数字，表示正在执行的指令；

![image-20230414180655233](/软件设计师笔记_files\image-20230414180655233.png)

## 3.6 流水线计算
- k为取指、分析、执行共 3段；t为流水线周期（取三段中最大的耗时时长）；
- 理论计算： 第一段 为建立时间 2+2+1ns ,其他为 一个流水线周期 总数99x2, 全部完毕需要时间5+99*2 = 203；
- 实际计算: 3表示三段 全部完毕需要时间  (3+99)*2 = 205；

![image-20230414181010961](/软件设计师笔记_files\image-20230414181010961.png)

## 3.7 流水线吞吐率计算
- 流水线的吞吐率 = 总指令数（100）/ 流水线的执行时间 (203);数据使用上题数据；
- 最大吞吐率: 就是流水线执行时间趋近一个流水线周期；

![](软件设计师笔记_files/5.jpg)

- 不使用流水线的执行时间：相当于每个指令是执行2+2+1=5ns再 5*100条指令=500；

![image-20230414184424041](/软件设计师笔记_files\image-20230414184424041.png)

- 一条指令完成需要消耗的时间片：(t+t+t+3t)
- 总共是4个任务占用的时间区：(t+t+t+3t)x4
- 每个指令时间区是：15t，4个流水段的总的时间区是 15tx4
- 流水线效率 =  (t+t+t+3t)x4 / 15t x 4

![image-20230414184346733](/软件设计师笔记_files\image-20230414184346733.png)

## 3.8 层次化存储结构
- 1bit = 8byte; 1kb = 1024byte;1M = 1024kb;
- 时间局部性原理，在短时间内会再次使用内存中数据Cache,提高速度;
-  BIOS（Basic Input Output System）（基本输入输出系统）是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息；             

![image-20230414184523585](/软件设计师笔记_files\image-20230414184523585.png)


## 3.9 Cache概念
- **全相联地址映射**：主存的任意一块可以映象到Cache中的任意一块;
- **直接相联映射**：主存中一块只能映象到Cache的一个特定的块中;
- **组相联的映射**：各区中的某一块只能**存入缓存的同组号的空间内**，但组内各块地址之间则可以任意存放。即从主存的组到Cache的组之间采用直接映象方式，在两个对应的组内部采用全相联映象方式;
-  Cache与主存之间的映射由硬件实现，主存与辅存之间的交互是硬件与软件结合起来实现的;    
- 速度最快：寄存器 > Cache > 内存 > 主存
- h表示Cache 命中率；
- 系统的平均周期 = h x t1(Cache周期时间) +  (1 -  h) x t2(主存储器周期)；

![image-20230414185420565](/软件设计师笔记_files\image-20230414185420565.png)

## 3.10局部性原理
- 空间局部性：对于数组的处理，邻近的距离的空间并立即访问；
- 时间局部性原理: 在短时间内会再次使用内存中数据Cache;

![image-20230414185744862](/软件设计师笔记_files\image-20230414185744862.png)

## 3.11主存 - 分类
- 只读存储器：在断电之后依然能保存数据；

![image-20230414190126518](/软件设计师笔记_files\image-20230414190126518.png)

## 3.12 主存 - 编址

- 8x4位的存储器：8代表8个地址空间，每个地址存储 4代表存储4个bit位；

- 内存地址是从AC000H 到 C7FFFH ，共有地址单元：表示大的值减去小的地址并且加1；

- C7FFFH + 1 = C8000H; (H不参与计算只是标识)

- K个地址单元：K 表示需要 除以 2^10 ，所以共有地址单元 1C000 / 2^10 = 112;

  ```
           C8000
  	   - AC000
  	   ----------------
  	     1C000
  	   8进行借位 是 16（因为是16进制） 8+16=24
  	   而 C 表示 12; 24-C = 12;
  	   1C000 转十进制 = (1*16^4+12*16^3) / 16*16*4 = 112;
  ```

- 芯片每个存储单元存储位 X 等于

  ```
  (112K * 16) / 28*16k*X = 1; 得出 X = 4; 
  ```

- 答案:  （B）112K个地址单元、(A) 4位;

![image-20230414190324294](/软件设计师笔记_files\image-20230414190324294.png)

## 3.13 磁盘结构和参数

- 最好的寻道时间就是磁盘不旋转就在当前位置，最坏的寻道时间是旋转一周的时间；

![image-20230417095323964](/软件设计师笔记_files\image-20230417095323964.png)



### 试题一

- 单缓存区表示 只能读取一个逻辑记录存入缓存区，然后再进行处理；
- 磁盘旋转起来是不会停止，而是会一直匀速旋转，所以磁盘不会等待缓冲区中的数据处理完；
- 读取一个逻辑记录是 33ms / 11 = 3ms;
- 周期为一周 33ms,如果是顺序单一缓存，读取一个3ms ,再处理需要 3ms,相当于处理完 R0 磁盘到了R1 结尾，则需要转一圈到R1开始位置读取并存入缓存，比如处理完R0 总共需要 3ms(读取) + 33ms(旋转一周并包含处理时间)，总共需要计算10个；

- R10读取和处理完等于 3ms(读取) + 3ms（处理） = 6ms;
- 最长时间是：(3+33) x 10 +6 = 366;
- 最短时间（可以把存储信息优化分布），可以间隔一个逻辑记录比如R0与R1 之间间隔R6, 所以读取完一个R0 需要 3ms(读取)+3ms(处理)，总共11个，总共最少时间是 6*11 = 66ms;

![image-20230417100001522](/软件设计师笔记_files\image-20230417100001522.png)





## 3.14 总线

- **地址总线**传输CPU发出的地址信号；
- **数据总线**传输数据信息；
- **控制总线传**输控制信号；
- **外部总线**是指计算机与外围设备之间传输数据和控制信息的电路集合；
- **内部总线**是指计算机内部各个组成部分之间传输数据和控制信息的电路集合；

![image-20230417104129059](/软件设计师笔记_files\image-20230417104129059.png)

# 4. 系统可靠性分析
## 1.1 串联系统与并联系统

- 串联模型只有整个环节都正常，才能正确；R表示可靠度，所以其公式: R = R1xR2x...xRn;
- 失效率不可靠计算，不准确；

![image-20230417104923540](/软件设计师笔记_files\image-20230417104923540.png)

- 1 - R 表示失效率，再通过 1- 失效率（如果有多个失效率就是用乘积）得到最终可靠度；

![image-20230417105258041](/软件设计师笔记_files\image-20230417105258041.png)

## 1.2 模冗余系统 与 混合系统

- R1等通过表决器通过多个相同输入，选中多个输出的可靠值；

![image-20230417110010334](/软件设计师笔记_files\image-20230417110010334.png)

## 1.3 差错控制

- 码距可以作为判断是否传输出错；
- 如果要检测有e个误码，码距就是要 >= e+1;
- 如果要纠正有t个误码，码距就是要 >= 2t+1;
- 常用**三种校验码**： 奇偶校验码、海明码、循环冗余校验码（CRC);
- **循环冗余校验码**广泛应用于数据通信领域和磁介质存储系统，利用生产多项式为k个数据位产生r个校验位来进行编码，器编码长度为 k+r；

![image-20230417110216328](/软件设计师笔记_files\image-20230417110216328.png)

## 1.4 海明校验码

- 2^0 、2^1等指数累加 位置存放校验位，其他位置为信息位；
- 图表中 r 表示校验数，I 表示信息数；
- 信息 位 I 表示，得出校验公式是：2^r >= I + r +1
- r2的校验码是根据 7 和 6 和 5等于中有 2^2 ，所以根据规律 r2 = I4 异或 I3 异或 I2; 其他同理；
- 纠错是根据传送的校验位数和数据中的校验位进行 异或操作就可以判断出 出错位置；一旦信息出错就以当前位置取反；

![image-20230417111111118](/软件设计师笔记_files\image-20230417111111118.png)

# 5. 操作系统基本原理

## 5.1 概述

![image-20230417114023308](/软件设计师笔记_files\image-20230417114023308.png)

- 前趋图（precedence diagram）是一种用于表达任务或活动之间关系的图形工具，通常应用于项目管理中。前趋图中每个节点代表一个任务或活动，节点之间的箭头表示它们之间的先后关系；
- 位示图（bitmap）是一种存储位图数据的数据结构，通常用于计算机图形学和操作系统中。它将图像分成一个个小块，每个小块对应一个二进制位，表示该位置是否有颜色或像素点；

![image-20230417114123612](/软件设计师笔记_files\image-20230417114123612.png)

## 5.2 进程管理 - 进程状态
- 只有就绪状态才能进入运行 状态

![image-20230417114515106](/软件设计师笔记_files\image-20230417114515106.png)

## 5.3 进程管理 - 前趋图
![image-20230417114804311](/软件设计师笔记_files\image-20230417114804311.png)

## 5.4 进程管理-同步、互斥

- **同步**是指协调多个程序或线程之间的**执行顺序和时序**，以保证它们能够正确地协同工作;
- **互斥**是为了防止多个进程或线程**同时访问某个共享资源**而引入的一种机制，只有获得了**互斥锁（Mutex）**才能**访问该资源**，从而避免竞态条件（Race Condition）等问题;

![image-20230417114906227](/软件设计师笔记_files\image-20230417114906227.png)

## 5.6 PV操作
- 临界区是代码段；
- 信号量是PV操作中的变量；
- 缓存溢出是需要PV操作解决；

![image-20230417160710324](/软件设计师笔记_files\image-20230417160710324.png)

- 前提生产了一个产品，S1初始值 为 1 ，S2 初始值0；
- 通过P(S1)将 S1 - 1 得到 S1为 0；
- 再通过V(S2) 将 S2 + 1 得到 S2 为1；

![image-20230417161858092](/软件设计师笔记_files\image-20230417161858092.png)

- P 操作进行阻塞(小于0)，V 不能进行阻塞（大于0）；
- P操作会先检查信号量是否可用（**小于 0 就阻塞**），如果可用就使用它，否则就等待；
- V操作（也称为signal操作）会增加一个信号量的值，同时唤醒可能正在该信号量等待队列中等待的进程;
- a1 进行 V(S1)操作请求付款操作，b1进行P(S1)操作阻塞付款流程，a2进行P(S2)操作等待收营员收费等操作，在b2进行 V(S2)操作收营员消磁等操作；

**在分析问题的时候可以先假设没有pv操作，分析会产生什么问题，再将pv操作加入看看能否解决问题。**

p是阻塞（加锁），v是解锁。解锁对应信号量的p所在的进程。

![image-20230417163108123](/软件设计师笔记_files\image-20230417163108123.png)



![image-20230417170529358](/软件设计师笔记_files\image-20230417170529358.png)

- P 操作是 减 1 ，小于0 就是放入阻塞队列中；

- V 操作是 加 1 ，小于等于 0 就放入阻塞队列中；

- 箭头 结束位置为 P操作，箭头开始位置为 V 操作；
- a和b 分别为 V(S1)和V(S2)进行操作，c 和 d 分别进行 （P(S1), P(S2)）和  (V(S3),V(S4)) ，e和f 进行 P(S3)和P(S4)

**快捷思路：信号量依次从左到右、从上到下标注出来；箭头 结束位置为 P操作，箭头开始位置为 V 操作；**

![image-20240512145829087](/软件设计师笔记_files\image-20240512145829087.png)

## 5.7 进程 死锁

- 最少多少个资源： 

  ```
  k 表示 多少个进程，比如 3个；n表示每个进程需要多少个系统资源；得出的公式可以不造成死锁如下：
  k x (n - 1) + 1;
  就是每个进程都缺一个资源，再加入一个资源，就不会造成死锁；
  ```

  

![image-20230417172557027](/软件设计师笔记_files\image-20230417172557027.png)

- 不造成死锁条件： 互斥、保持和等待 、 不剥夺、环路等待；

![image-20230417173531500](/软件设计师笔记_files\image-20230417173531500.png)

### 银行家算法

![image-20230417173757995](/软件设计师笔记_files\image-20230417173757995.png)

### 银行家算法例子

- 分别计算出剩余多少个资源：2 、1 、 0；
- 优先执行可以继续执行，并执行完成后会释放资源；
- 所以 根据 剩余资源，P2 优先执行后会释放，之后就是P4进行执行并释放，类似这样推导结果对比出；

![image-20230417173925931](/软件设计师笔记_files\image-20230417173925931.png)

![image-20240512151337298](/软件设计师笔记_files\image-20240512151337298.png)

## 5.8 存储管理- 分区存储组织

- 使用完的空间，会释放空间；
- 首次适应算法： 第一次遇到的空间，能访问的并能容纳的空间切出；

- 最佳适应算法： 最小的空间能用的，以通过链接方式从小到大，取空闲最小的空间；（内存碎块比较多）

- 最差适应法： 从小到大排列，取最大的空间能用的；

- 循环首次适应法： 循环遍历存放；

![image-20230418162230997](/软件设计师笔记_files\image-20230418162230997.png)

## 5.9 存储管理 - 页式存储

- 将用户程序等分 比如 4K一页，页表记录内存块映射关系；
- 逻辑地址和物理地址的页内地址是一致；页号和块号不定相同；
- 逻辑地址的**页号** 通过**页表查到**对应页号的**块号**；

![image-20230418162624481](/软件设计师笔记_files\image-20230418162624481.png)

### 练习题

- 页面大小为 4K = 2^12，说明一个页的页面地址是12位；高于12位是页号；

- 二进制转为 十六进制，是每4位 按权展开计算得到，所以页面内地址是**A29**；页号就是 5，对应表中的物理块号（页帧号）的6；（1）答案：6A29H;
- 淘汰页号就要淘汰在内存中的页（状态位是1的），因为3和4 都不在内存中，所以剩余0、1、2、5
- 访问位为1 是需要访问的，不能淘汰，只能淘汰访问位为0的，所以只能取页号为1，**淘汰页就是 1号页**；
- 系统应该首先淘汰未被访问的页面，因为根据程序的局部性原理，最近未被访问的页面下次被访问的概率更小，如果页面最近都被访问过，应该先淘汰未修改过的页面，因为 未修改过的页面内存和辅存一致，故淘汰时无需写回辅存，使系统页面置换代价小；

![image-20240512153426092](/软件设计师笔记_files\image-20240512153426092.png)

## 5.10 存储管理 - 段式存储组织

- 把程序和数据划分成若干个逻辑段，每个段拥有独立的地址空间，相互之间可以保持隔离；
- 按逻辑结构划分段，段可长可短（不像页那样固定），便于共享；
- 段表存：段号、段长、基址；

![image-20230418165540945](/软件设计师笔记_files\image-20230418165540945.png)

## 5.11存储管理 - 段页式存储组织

- 是页式和段式的综合；先分段再分页；

![image-20230418170407018](/软件设计师笔记_files\image-20230418170407018.png)

## 5.12 存储管理  - 快表

- 小容量相联存储器、高速缓存器、速度快、存放当前访问最频繁的少数活动页面页号；
- 快表是一种常见的缓存机制，可以将常用的数据放在快表中，以加速对这些数据的访问;
- 如果系统中没有使用快表，则每次访问数据时都需要从主存（或磁盘）中读取数据，这会导致访问速度变慢;

![image-20230418170623630](/软件设计师笔记_files\image-20230418170623630.png)

## 5.13 存储管理 -  页面置换算法

- 使用分层存储管理体系中；
- 将程序分为多个页，但只能存储几个页，算法只存要使用的页；
- 抖动：加入资源页后，缺页数量反而增加了 ；

![image-20230418170923171](/软件设计师笔记_files\image-20230418170923171.png)

- 行头表示要访问页面的序列；
- 列头（1，2，3）表示内存3个页面；
- 比如访问页号为4，将存入 内存页 1中，并标记为缺页；
- 如果内存页满了，淘汰就会淘汰最先进入的页号；
- 当把内存页数从3达到4的时候，如下列表计算出缺页数是10 大于之前的内存页数3，就是为抖动；

![image-20230418171719853](/软件设计师笔记_files\image-20230418171719853.png)

### 试题一

- 总共只能容纳内存空间为3个页，访问页号2的时候发现空间不足，需要淘汰，FIFO 就会淘汰最先进入，LRU会淘汰不是最近使用的5号页； 
- 勾选表示 缺页；

![image-20230418172526962](/软件设计师笔记_files\image-20230418172526962.png)

### 试题二

- 当需要访问一个新的内存地址时，首先需要将该地址所在的页加载到主存中，这个过程通常称为“缺页”。当页面被加载到主存中后，如果该页的数据也在主存中，则可以直接从主存中读取数据，访问次数为1次；否则需要再次从磁盘中读取数据，并将其放入主存中，此时访问次数为2次；
- 没有使用快表，说明每次读内存的块，都需要在内存上查表然后再读取相应的内存块，所以每次都需要2次内存的访问，总共有6个块，需要访问 12 次内存；
- 页面大小为1K ，就是一个K就是一个块，swap指令是需要存两个块，理论是两次缺页中断，而**指令只会产生1次缺页中断**；而数据A和B是都占用2次缺页，所以总共位 5次缺页中断；
- 缺页表示不存在内存块中；

![image-20230418173217941](/软件设计师笔记_files\image-20230418173217941.png)



## 5.14 文件管理 - 索引结构

- 索引文件结构- 直接索引比如 每个块4K总共 13个块 4x13 = 52K
- 10号盘块一级间接索引，每个物理盘块是4K,而10号中每个地址为4个字节，总共可以存4K/4 = 1024个地址；每个地址指向一个物理盘块，这个物理地址才存索引文件的内容；
- 一级间接索引可以存的大小为 4K x 1024 容量；
- 11号盘块二级间接索引，节点地址对应的盘块存地址，地址对应下一级盘块还存地址，最后才指向物理盘块，间接的级别越多访问效率越低；
- 二级间接索引可以存的大小为 4K x 1024 x 1024容量；

![image-20230419112024307](/软件设计师笔记_files\image-20230419112024307.png)

### 试题一

- 逻辑块号一般是从0 开始；
- 逻辑块5号为一级间接地址索引，5号块指向的物理盘块号就是58；
- 一个物理盘块是1K大小，一个地址是4字节，每个盘块可以存 1K / 4 = 256个地址；而逻辑号5到261号大小就是 261 - 5 = 256 个地址，所以只能是下一个盘块的第一个187；
- 101号物理块是iaddr[7]其采用的是二级间接地址索引；

![image-20230419114626644](/软件设计师笔记_files\image-20230419114626644.png)

## 5.15 文件和树型目录结构
![image-20230419144230332](/软件设计师笔记_files\image-20230419144230332.png)

## 5.16 空闲存储空间的管理

- 四种方法都是操作系统中**管理空闲内存块**的方式；

1. 空闲区表法：将内存分为**多个大小相等的区域**（通常称为内存块），并将每个内存块标记为“已使用”或“未使用”。空闲区表则记录所有未使用的内存块，包括**每块内存的起始地址和长度**等信息。
2. 空闲链表法：类似于空闲区表法，但将**所有未使用的内存块用链表连接**起来，链表中每个节点表示一个未使用的内存块，其中包括该内存块的起始地址和长度等信息。
3. 位示图法：将整个内存分为多个大小相等的块（通常为字节或位），并为每个块分配一个二进制位。如果一个内存块未被使用，则对应的二进制位为0，否则为1。通过检查位示图即可确定哪些内存块未被占用。**1 是占用 0 未用**;
4. 成组链接法：将内存块按照一定的大小分为多个组，并将**同一组内的所有块用链表连接**起来。每个内存块的前几个字节用于记录所属的组号、下一块地址等信息。

- 这些方法各有优缺点例如，空闲区表法需要维护一个表格，占用了一定的内存，但查找未使用内存块的速度相对较快；空闲链表法需要指针操作，可能会造成额外开销，但更加灵活。位示图法可以减少内存开销，但需要进行位运算等操作。成组链接法则将内存分组，能够高效地利用碎片化的空闲内存；

![image-20230419144550746](/软件设计师笔记_files\image-20230419144550746.png)

### 试题一

- 一个字为32位，因为物理块号是从0 开始的，而4195号物理块是从0开始的结束物理块号，所以 （4195 + 1）/ 32 = 131.125；因为超过131号就是要到132号;
- 第几个字中描述，表示从1 开始，所以答案是 132 (D);
- 第几位是从0 位置开始，因为 131 * 32 = 4192 表示 0 - 4191，而4192为0 位置，4193为 1位置，4194为2 位置 ,4195为3位置；
- 所以系统应该将该字的第3位置“1” 答案：B;

![image-20230419145450275](/软件设计师笔记_files\image-20230419145450275.png)

### 试题解答

![image-20230419150443870](/软件设计师笔记_files\image-20230419150443870.png)

## 5.17 设备管理 -数据传输控制方式

- **程序控制方式**是指计算机处理器**（CPU）**执行程序时按照**程序指令的顺序依次执行**，即由当前指令所指向的下一条指令来控制程序的执行过程。在程序控制方式下，处理器需要不断地获取并解析下一条指令，然后执行其定义的操作。这种方式下的程序实现相对简单，但效率较低，特别是对于一些**需要进行复杂逻辑判断或大量数据运算的程序**，会降低系统的响应速度；
- **中断控制方式**，它允许 CPU 优先响**应来自外部设备的信号**（如键盘输入、网络数据等），并**自动转入相应的程序执行中**。这种方式可以提高计算机的响应速度和工作效率，常用于实时操作系统、多任务操作系统等场景;
- **DMA 全称为“Direct Memory Access”**，它是一种**计算机数据传输方式**。DMA 可以让外设（如硬盘、网卡等）在与内存的数据传输过程中，**直接控制系统内存而不需要 CPU 的干预**，从而**提高数据传输速度和 CPU 的处理能力**。具体来说，DMA 控制器可以在系统总线空闲时暂时抢占总线，直接访问内存并传输数据，当传输完成后再将总线让给其他设备诸如 CPU 等。这样就可以避免数据传输时造成的 CPU 繁忙、总线过载等问题，并解放 CPU 资源，因此 DMA 在提高数据传输效率方面发挥了重要作用;
-  直接主存存取（Direct Memory Access，DMA）是指数据在主存与I/O设备间（即主存与外设之间）直接成块传送；

![image-20230419151235875](/软件设计师笔记_files\image-20230419151235875.png)

## 5.18 设备管理 - 虚设备与 SPOOLING技术

- SPOOLING（Simultaneous Peripheral Operations On-line）技术是一种在计算机系统中**用于缓存和管理输入/输出（I/O）数据的方式**。通过使用SPOOLING技术，系统可以将I/O请求从高速设备（如硬盘、光盘等）转移到低速设备（如打印机），从而使高速设备可以快速地处理其他任务，而不必等待I/O操作完成；
- 由于**所有的I/O请求都经过了缓存和调度**， SPOOLING技术可以避免竞争和冲突。例如，在多个程序同时请求打印时，SPOOLING系统会自动将它们排队，并按照请求的顺序打印文件。这可以保持系统的稳定性并减少错误发生的可能性。
- 总体来说，SPOOLING技术已成为一种基本的I/O管理技术，广泛应用于许多领域，包括操作系统、数据库、网络通信等；

![image-20230419153234150](/软件设计师笔记_files\image-20230419153234150.png)

## 5.19 微内核 - 操作系统

- 微内核是一种操作系统内核设计思想，它将操作系统中的**基本功能进行细分**，并将其封装成**独立的进程或者服务**。相比于传统的单内核设计，**微内核的优点**在于更好的**灵活性、可移植性和安全性**。但是，由于**微内核在进程间切换时的开销较大**，在实际应用中常常面临性能问题。

![image-20230419173939044](/软件设计师笔记_files\image-20230419173939044.png)

# 6. 数据库

## 6.1 数据库内容提要

- 重点 ER模型、关系代数与元组演算、规范化理论等；

![image-20230420150351295](/软件设计师笔记_files\image-20230420150351295.png)

## 6.2 三级模式 - 两级映射

- 数据库的**三级模式**指的是外模式、概念模式和内模式，而两级映射指的是概念模式与外模式之间的映射和概念模式与内模式之间的映射。

1. **外模式**（也称为用户模式）：是面向具体应用的**数据视图**。这个模式表示了用户看到和使用的部分数据库，并且通常是由应用程序员或最终用户定义的。一个数据库系统可以有多个外模式。
2. **概念模式**（也称为全局模式或逻辑模式）：是对整个数据库的**全局逻辑结构和特征的描述**。这个模式表示了数据库中所有数据的逻辑上的结构和关系，并且通常是由数据库管理员定义的。
3. **内模式**（也称为存储模式）：是对**物理存储结构和存储方式**的描述。这个模式表示了数据在磁盘等存储设备上如何存储，以及如何访问和更新数据。它通常是由数据库管理系统(DBMS)自动生成和维护的。

- 两级映射：

1. 概念模式和外模式之间的映射：描述了如何将概念模式转换成各个外模式，是表示不同用户感兴趣的数据的一种方式。
2. 概念模式和内模式之间的映射：由DBMS自动进行，描述了概念模式如何被映射到实际的存储结构。

- 数据库系统通过这样的三级模式和两级映射来实现不同用户对同一数据库的不同需求，并且使得数据在物理存储层次上与逻辑组织层次上相分离。这种分层方式使得数据库系统更加灵活、易于维护和扩展。

![image-20230420150500446](/软件设计师笔记_files\image-20230420150500446.png)

## 6.3 数据库设计过程

- 数据库设计是一个重要的过程，主要包括以下几个步骤：
  1. 需求分析：明确需求，包括数据的类型、数据量、数据结构以及数据之间的关系等。
  2. 概念设计：根据需求分析得出**数据模型**，使用ER图描述实体类、属性和实体关系，并确定主键和外键等。
  3. 逻辑设计：将概念设计转化为具体的关系模式，包括**表的定义、各字段数据类型**、长度限制、默认值、约束条件等。
  4. 物理设计：确定具体的数据库系统和存储引擎，包括**分区、索引、视图和存储过程**等。
  5. 实施与维护：建立数据库并完成相关配置，进行数据库测试和调优，并定期进行维护和备份等。

- 在以上过程中，需要注意保证数据库的可扩展性、安全性、可靠性和高效性，并遵循规范化的设计原则和标准化的开发流程。

![image-20230420151500702](/软件设计师笔记_files\image-20230420151500702.png)

## 6.4 E-R模型

- E-R模型，全称实体-关系模型（Entity-Relationship Model），是一种数据模型；

- 用于描述现实世界中的对象之间的关系。**E-R模型中**，实体表示现实世界中的对象，**关系表示对象之间的关系**；

- 实体和关系都有属性，属性描述了实体或关系的特征。E-R模型是一种图形化的表示方式，通常使用**矩形表示实体**，**菱形表示关系**，**箭头**表示关系的方向，**线条**表示属性或关系的类型；

- E-R模型是数据库设计的基础，可以用来设计关系型数据库的结构；

  

![image-20230420154047143](/软件设计师笔记_files\image-20230420154047143.png)

- 先画局部E-R模型再合并；

![image-20230420155259464](/软件设计师笔记_files\image-20230420155259464.png)

### 试题一

- 一个实体型转换为一个关系模式；
- 一个1对1 的两个实体，可以转成 一个中间关系模式（共3个关系模式），也可以转成两个关系模式（把关系放入其中的一个实体中）最多转为3个关系，最少2个关系；
- 一个1对多的两个实体（部门对员工关系）,联系只能记录在员工这边，员工关系中加入部门号，最少2个关系；
- 一个多对多的两个实体（学生和课程关系），多对多的联系必须转为一个实体，所以必须最少转为 3 个关系；
- 多对多的三个联系 m、n、p的关系，首先三个实体转为3个关系，联系转为1个关系，最少可转换为 4 个关系模式；

![image-20230420155618573](/软件设计师笔记_files\image-20230420155618573.png)

## 6.5 关系代数

- 关系代数是一种用于描述关系型数据库操作的形式化语言。它提供了一组基本操作，包括选择、投影、连接、并集、差集等，可以用来描述和操作关系型数据库中的数据。

- 以下是关系代数的基本操作：

1. 选择（Selection）：从关系中选择满足指定条件的行。
2. 投影（Projection）：从关系中选择指定列。
3. 连接（Join）：将两个关系组合起来，形成一个新的关系。连接操作有多种类型，包括自然连接、内连接、外连接等。
4. 并集（Union）：将两个关系合并为一个新的关系,去掉重复的行数据。
5. 差集（Difference）：从一个关系中删除另一个关系中的行。
6. 交集（Intersection）：选择两个关系中共有的行。
7. 分组（Group By）：将关系按照指定的列进行分组。
8. 聚集（Aggregate）：对分组后的结果进行聚集计算，如求和、平均值、最大值、最小值等。

- 以上操作是关系代数中的基本操作，可以通过这些操作来描述和操作关系型数据库中的数据;

![image-20230420164945761](/软件设计师笔记_files\image-20230420164945761.png)

- 笛卡尔积就是 两个表关系的乘积；
- 投影是选列的操作，选出需要的，没有去掉重复的；
- 选择是选出对应的行数；

![image-20230420165432889](/软件设计师笔记_files\image-20230420165432889.png)

- 连接操作是去掉重复公共的字段；
- 连接的条件默认是自然连接，表示相同的字段做连接操作比如使用sno字段；

![image-20230420170304851](/软件设计师笔记_files\image-20230420170304851.png)

## 6.6 规范化理论 - 函数依赖

- 主键是两个属性的组合键，组合键可以确定关系C，而组合键中的键也可以确定关系C，就是部分函数依赖；
- 传递性依赖就是A可以确定B 而B又可以确定C ，而B不能确定A，因为如果确定的话，A和B就是等价的，就不是传递性依赖了；

![image-20230420171108043](/软件设计师笔记_files\image-20230420171108043.png)

## 6.7 规范化理论 - 价值与用途

- 数据冗余：DNO系号和DNAME 系名是一一对应关系，所以冗余；
- 更新异常：比如要更新计算机系为计算机科学系，就需要更新表所有DNAME中的名称；
- 插入异常：是两个主键确定才能插入，如果只有一个主键就会插入异常；
- 删除异常：因为冗余，删除了不该删除的数据；

![image-20230420172751020](/软件设计师笔记_files\image-20230420172751020.png)

## 6.8 规范化理论 - 键

- 例子：学号和姓名 可以确定性别；
- **超键**： 是可以唯一标识关系中的每一条记录的**一个或多个属性集合**(超键可能包含候选键、主键或其他属性集合)，可能存在冗余属性；所以（学号和姓名）可以成为 超键；
- **候选键**：是指可以唯一标识关系中**每一条记录的最小属性集合**，在候选键中，任意一个属性都不能被删除，否则就不能唯一标识记录了，候选键不会存在冗余属性; 所以 只要学号就行；
- **主键**：是一种特殊的候选键，用于唯一标识关系中的每一条记录。主键必须是**唯一的，不允许为空**，并且不能被修改；
- **外键**: 指在一个关系中，引用**另一个关系的主键作为自己的一个属性**，用于建立关系之间的联系;

![image-20230420173424922](/软件设计师笔记_files\image-20230420173424922.png)

## 6.9 规范化理论 - 求候选键

- 函数依赖关系- 有向图
- 入度为0 的属性 以该属性集合为起点，遍历有向图，能正常遍历图中的所有结点，则该属性集为关系模式候选键；
- 当入度为0的属性集不能遍历图中所有结点，则可以将中间结点（有入度，也有出度）并入 入度为0 的集中，直到可以遍历所有结点，就为候选键；

![image-20230421111541622](/软件设计师笔记_files\image-20230421111541622.png)

### 试题 一

- 入度为0 就是没有箭头指向它，出度就是它自己有箭头指出去；
- 例1：R的候选关键字通过有向图，判断，A1为入度，可以遍历所有结点；所以R的候选关键字是A1；
- 例2：注意ABD ->E 必须画到一个点，再从点到E; 依据图所以ABDC为候选键，才能遍历所有节点；
- 例3： 依据图，A可以到B和C，而B也可以到A和C ，所以候选关键字是A和B;

![image-20230421111723289](/软件设计师笔记_files\image-20230421111723289.png)

## 6.10 规范化理论 - 范式

1. **第一范式（1NF）**：**属性不可再分**。即每个属性都是不可分的基本数据项。
2. **第二范式（2NF）**：属性完全依赖主键。即每个非主键属性都完全依赖于主键，而**不是依赖于候选键的一部分**。
3. **第三范式（3NF）**：非主键属性不依赖于其他非主键属性。即每个**非主键属性**都**不依赖**于其他**非主键属性**。
4. 巴斯-科德范式（BCNF）：属性完全依赖于候选键。即每个属性都完全依赖于候选键，而不是依赖于候选键的一部分。
5. 第四范式（4NF）：多值依赖。即如果一个关系表中有多个多值依赖关系，应该将其拆分为多个关系表。
6. 第五范式（5NF）：联合依赖。即如果一个关系表中有多个联合依赖关系，应该将其拆分为多个关系表。

![image-20230421114103288](/软件设计师笔记_files\image-20230421114103288.png)

### 第一范式

- 关系R不满足1NF, 应该把高级职称人数去掉, 转为 教授、副教授；

![image-20230421165237233](/软件设计师笔记_files\image-20230421165237233.png)

### 第二范式

- SNO学号 、CNO课程号、CRADE成绩、CREDIT学分；
- CREDIT学分可以只要 CNO课程号就可以确定，存在部分依赖关系；
- 学分 有数据冗余、并更新异常；
- 如果需要插入 新的学分信息，但不存在学生号选择，所以不能插入，插入异常；
- 如果学生信息删除了，学分也就删除；删除异常； 

![image-20230421165504893](/软件设计师笔记_files\image-20230421165504893.png)

### 第三范式

- 第三范式要求除主键以外的所有字段都不相互依赖，而是互相独立；
- 单主属性是不存在部分依赖的关系；
- 解决方案：将DNO、DNAME、LOCATION可以划为一个表关系、脱离出来；把SNO、SName 、DNO作为一个表关系；

![image-20230423111951762](/软件设计师笔记_files\image-20230423111951762.png)

### BC范式

- 主属性 属于 候选键，其他为非主属性；

- S和J一起确定 T，而S和T可以确定 J; ST、SJ是候选键，所以没有非主属性，就满足1NF和2NF;
- BC范式的决定因素是候选键；
- 函数式依赖关系有 SJ =》T 、T =》J ；左侧为决定因素，但T不是候选键；所以不是BC范式；

![image-20230423112657784](/软件设计师笔记_files\image-20230423112657784.png)

### 规范化理论 - 例题

- 表1 主键是部门号，只有多个主键的组合键才有部分函数依赖问题，所以部分函数依赖已消除；
- （1）因部门关系不属于第三范式，所以一定是没有消除传递函数依赖；
- （2）需要员工表关联到部门关系，员工对部门是多对1的关系，所以需要在员工表3中加入部门号；
- （3）增加关系模式，需要每种商品只能由一个部门负责关系，所以只需要 销售（职工号、商品号、日期、数量）；

![image-20230423141729709](/软件设计师笔记_files\image-20230423141729709.png)



## 6.11 规范化理论 - 模式分解

在进行模式分解时，需要**保证拆分后的关系模式**仍然能够**满足原始关系模式**中的函数依赖关系。如果**拆分后**的关系模式**不能满足函数依赖关系**，就可能出现**数据冗余、数据更新异常**等问题

> 保持函数依赖分解,举例关系: R(A,B,C)
- R(A,B,C) 可以 推导出 R1(A,B)/R2(B,C)，就是说保持了函数依赖分解；
- 而R3(A,C)是冗余关系，因为R1(A,B)/R2(B,C)是可以推导出R3(A,C)关系；

![](软件设计师笔记_files/72.jpg)

### 试题一

如下解析：成绩与学生 相当于 表（关系模式）的连接关系推导出；

![](软件设计师笔记_files/73.jpg)

### 试题二

> 列表法 - 模式分解
- 首行是原关系的中的字段信息（学号等）
- 首列是 拆分的 几个关系模式 (成绩等)
- a1表示包含字段为第一列，b12表示没有包含字段，第一行第二列；

![](软件设计师笔记_files/74.jpg)

![](软件设计师笔记_files/75.jpg)

### 试题三

- R减操作 表示去掉公共部分，例如 AB - AC 得 B; AC - AB 得 C;

![](软件设计师笔记_files/76.jpg)

## 6.12 并发控制 - 基本概念

![](软件设计师笔记_files/77.jpg)

### 并发控制-存在的问题示例

![](软件设计师笔记_files/78.jpg)

### 并发控制 - 封锁协议

![](软件设计师笔记_files/79.jpg)

## 6.13 数据库完整性约束

- 实体完整性约束：定义主键不能为空、重复
- 参照完整性约束：外键，如员工表中用外键 部门号
- 用户自定义完整性： 如字段 年龄 不能大于300 小于0

![](软件设计师笔记_files/80.jpg)

## 6.14 数据库安全

![](软件设计师笔记_files/81.jpg)

## 6.15 数据库备份

![](软件设计师笔记_files/82.jpg)

![](软件设计师笔记_files/83.jpg)

## 6.16 数据库故障与恢复

![](软件设计师笔记_files/84.jpg)

## 6.17 数据仓库 与 数据挖掘

- 数据记录会越积累越多，会影响应用查询性能，但又不能删除因为可以用于数据分析
- 数据仓库用于收集 源数据，作为仓库
- 数据挖掘用于分析历史数据的 规律

![](软件设计师笔记_files/85.jpg)

### 数据挖掘方法分类

![](软件设计师笔记_files/86.jpg)

## 6.18 反规范化操作

- 空间 换 时间 的概率，增加冗余字段，提高查询效率的性能；

![](软件设计师笔记_files/87.jpg)


## 6.19 大数据

- 针对数据 分析出一些关系（量变造成 质变）
- 高性能、高可用、高可靠；

![](软件设计师笔记_files/88.jpg)

![](软件设计师笔记_files/89.jpg)


# 7. 计算机网络

## 7.1 OSI七层模型

- 全双工通信是指通信双方可以同时进行发送和接收数据的方式(同时说话视频聊天)；
  半双工通信是指通信双方不能同时进行发送和接收数据的方式（对讲机）;

- 

- **中继器**（RP repeater）是工作在物理层上的连接设备，对信号进行再生和还原的网络设备，扩展网络的传输距离，提高传输质量，同时也能减少网络延迟；

- **集线器** 是将多条**以太网双绞线或光纤**集合连接在**同一段物理介质**下，形成一个多端口的转发器，网络中某条线路产生了故障并不会影响其它线路的工作；集线器（物理层） 广播（不安全、浪费了网络资源）半双工状态，多台设备不能同时发送数据包会发生冲突，性能差利用率比较低；

- **网桥**（bridge）是一种网络设备，属于OSI模型的**数据链路层设备**，用于连接两个或**多个局域网（LAN）并转发数据包**，以实现不同局域网之间的数据通信；

- **交换机** 具有更好的转发能力和管理功能，可以自动学习MAC地址并将数据包仅发送到目标设备上，并根据不同的端口进行流量控制，大幅减少了网络拥塞和冲突等问题；

  交换机（数据链路层），维护一张mac地址表；映射到对应的端口，同时值全双工通信，同时发送和接受保证了传播效率和可靠性；提高网络性能和链路的利用率；
  交换机的桥接可以建立多个网络设备连接在一起，通过桥接方式；

  mac表的建立
  1. 发送交换机
  2. 发现表中没有映射端口
  3. 转发所有的端口上的设备
  4. 通过数据包中源mac地址和目标mac地址不断更新其mac表
  5. 不断完善；

  

- **路由器** 以根据目的IP地址进行数据包的转发，从而实现不同网络之间的通信，具有转发、路由选择、拆分和重组数据、流量控制等功能；

- IP地址是由 32位的二进制组成、为了方便记忆一般会转成 4个8位的十进制以点连接的IP地址；
  每个IP地址是由网络地址和主机地址组成；
  网络地址是指示该设备所在的网络而主机地址是网络中的位置；

- 通过子网掩码（32位二进制）区分网络地址和主机地址；与IP地址进行逐位与运算得到主机地址；

  子网掩码有两种表示方法：1111111.11111111.11111111.00000000
   十进制表示法：255.255.255.0;
  CIDR表示法：192.168.1.0/24;表示前24位是网络地址，后8为主机地址；

  Mac地址是硬件层面，IP是软件层面的；每台主机都有Mac（不变）和IP（可变）地址；

- **ARP协议**：要获取同一个网络中的一个台设备的Mac地址，使用ARP协议向同一子网中广播一个ARP请求；
  当目标地址收到请求后，会判断是否与自己的IP地址匹配；
  如果匹配会把自己的Mac地址打包成一个ARP响应发送回请求设备；
  ARP协议是通过IP查询出Mac地址的协议；
- **路由表**示记录路由器所连接的**不同网络之间路径和关系**的一张表；

![](软件设计师笔记_files/90.jpg)

### 试题一

- 考察是否同一个局域网，局域网是不能通过在网络层传输，所以答案是 B, 因为P和S之间有路由器；

![](软件设计师笔记_files/91.jpg)

## 7.2 网络技术标准和协议

- **IPX/SPX协议**是一种网络通信协议的组合，与TCP/IP协议相比，IPX/SPX协议具有更快的传输速度和更好的可靠性；
- **NETBEUI**是一种轻量级、快速和简单的网络协议，适用于小型局域网中的计算机间通信;
- **ICMP**全称为Internet Control Message Protocol,用于在IP网络中传递控制信息和错误报告、网络故障诊断，如ping；
- **IGMP**全称为Internet Group Management Protocol,用于在IPv4网络中建立和管理组播组;
- **ARP**全称为Address Resolution Protocol，用于将IP地址解析为物理网络地址（MAC地址）；
- **RARP**允许在无磁盘机器上通过物理地址（MAC地址）查找其对应的IP地址；
- **UDP**全称为User Datagram Protocol，是一个简单的面向消息的传输协议,无需维护连接状态，因此协议栈的资源消耗较小;
- **SMTP**协议定义了电子邮件如何在网上通过电子邮件服务器进行发送、路由和接收的方式;
- **POP3**（Post Office Protocol 3）是一种用于接收邮件的标准协议，邮件客户端通过POP3协议与邮件服务器建立连接并进行身份验证，若验证通过，则可以从邮件服务器上下载邮件；
- **NFS**指的是Network File System，是一种基于文件系统的网络协议，允许用户透明地访问远程服务器上的文件;
- **SNMP**指的是Simple Network Management Protocol，是一个用于管理和监控网络设备的协议，底层通信使用的是UDP协议;
- **Telnet**是一种用于远程登录到计算机网络上的协议，允许用户在本地计算机上运行命令或应用程序，以访问远程计算机上的资源;

![](软件设计师笔记_files/92.jpg)

## 7.3 TCP 协议

![](软件设计师笔记_files/93.jpg)

## 7.4 DHCP 

- 分配到169.254.x.x或0.0.0.0 是因为DHCP服务器出故障或未联系上DHCP；

![](软件设计师笔记_files/94.jpg)

## 7.5 DNS 域名解析器

![](软件设计师笔记_files/95.jpg)

![](软件设计师笔记_files/96.jpg)

- 如果是递归是会询问其他服务器并有反馈箭头，所以根服务器不是递归是迭代，而中介域名服务器是递归，答案： A

![](软件设计师笔记_files/97.jpg)

## 7.6 拓扑结构

- 星型节点会点单故障

![](软件设计师笔记_files/98.jpg)

## 7.7 网络规划 与设计

![](软件设计师笔记_files/99.jpg)

### 网络规划与设计 - 逻辑网络设计

![](软件设计师笔记_files/100.jpg)

### 网络规划与设计 - 分层设计（考点）

![](软件设计师笔记_files/101.jpg)

## 7.8 IP地址

- **网络号** ( /24 表示 前24位网络号)指的是IP地址中标识该IP地址所处的网络的部分;
- **主机号**则是该IP地址所代表的主机在该网络中的编号;
- 网络号和主机号的划分方式取决于IP地址的子网掩码;

![](软件设计师笔记_files/102.jpg)

## 7.9子网划分

![](软件设计师笔记_files/103.jpg)

- 2多少个幂可以得到 27；2^5 = 32;就需要 5个 位作为 子网掩码并设置为1，再网络位都设置为1，得到子网络掩码： 255.255.248.0；

![](软件设计师笔记_files/105.jpg)

- 2^x - 2 >= 700；每位取0或1 因是 2的幂次方 减去 全0或全1两种，所以x为 10 位，其他为 1 ，得到子网络掩码： 255.255.252.0；

![](软件设计师笔记_files/104.jpg)

## 7.10 无分类编址（无类域间路由）

- 总共 32位，20为网络地址位数，其他为主机地址 2^12个

![](软件设计师笔记_files/106.jpg)

- C类地址网络位24，该网络是 20 ，所以能得到 4个位作为子网位就是可以 2^4 = 16个C类子网

![](软件设计师笔记_files/107.jpg)

## 7.11 特殊 IP地址 解释

![](软件设计师笔记_files/108.jpg)


## 7.12 标签hmtl (考试1分)
![](软件设计师笔记_files/109.jpg)

## 7.13 无线网
![](软件设计师笔记_files/110.jpg)

## 7.14 网络接入技术
![](软件设计师笔记_files/111.jpg)

## 7.15 IPV6
![](软件设计师笔记_files/112.jpg)

## 7.16 信息系统安全属性
![](软件设计师笔记_files/113.jpg)

## 7.17 对称加密 AES
![](软件设计师笔记_files/115.jpg)

## 7.18 非对称加密 RSA
- 计算量大，比较耗性能，一般用非对称加密的公钥加密 对称加密的秘钥 传输 给服务器端，再 服务器非对称加密的私钥 解密 得到 对称加密的 私钥，进行加密传输；

![](软件设计师笔记_files/114.jpg)

## 7.19 信息摘要
- 应用 信息是否串改，对比 摘要是否一致；
- 单向 hash,不可逆；

![](软件设计师笔记_files/116.jpg)

## 7.20 数字签名

- **数字证书**是一种用于验证数字身份的安全文件，它包含了一个人或实体的公钥、其姓名/机构名字和证书颁发机构(CA)的数字签名; **验证CA的签名时使用的是CA的公钥**；

![](软件设计师笔记_files/117.jpg)

## 7.21 数字信封与PGP

![](软件设计师笔记_files/118.jpg)

## 7.22 设计邮件 加密系统

- 1. 随机密钥k是对称加密 （加密邮件）
- 2. 传输 对称加密的私钥 到 接受方，用接受方的公钥 加密传输
- 3. 正文摘要，用发送方的私钥加密，接受方用发送方的公钥解密，对比摘要；

![](软件设计师笔记_files/120.jpg)

## 7.23 网络层次安全

- PPTP（Point-to-Point Tunneling Protocol）是一种用于创建虚拟私有网络（VPN）的协议；
- L2TP（Layer 2 Tunneling Protocol）是一种虚拟隧道协议，用于建立虚拟专用网络（VPN）连接；

![](软件设计师笔记_files/119.jpg)

### 网络安全- 网络威胁与攻击（1）

![](软件设计师笔记_files/121.jpg)

### 网络安全- 网络威胁与攻击（2）

![](软件设计师笔记_files/122.jpg)

## 7.24 防火墙
![](软件设计师笔记_files/123.jpg)

# 8. 数据结构与算法

![](软件设计师笔记_files/124.jpg)

## 8.1 数组

- len 表示 各元素占用字节
- 首地址 是 a 

![](软件设计师笔记_files/125.jpg)

## 8.2 希疏矩阵

- 稀疏矩阵是一种仅包含很少非零元素的矩阵
- 使用稀疏矩阵的主要原因是可以减少存储空间和计算时间

![](软件设计师笔记_files/126.jpg)

- 代入法，进行计算
- A00 是 M[1] 代入计算 i = 0  j =0;
- A11 是 因为是按行优先压缩存储所以是 M[3] 代入计算 i = 1 j = 1;
- 答案是 A

![](软件设计师笔记_files/127.jpg)

## 8.3 数据结构定义

- 非线性: 树、环路、图

![](软件设计师笔记_files/128.jpg)

## 8.4 线性表
![](软件设计师笔记_files/129.jpg)

![](软件设计师笔记_files/130.jpg)

![](软件设计师笔记_files/131.jpg)

## 8.5 线性表 - 顺序存储和链式存储
![](软件设计师笔记_files/132.jpg)

## 8.6 线性表 - 队列和栈

- 循环队列：head头和tail尾指向同一地方，添加一个元素需要tail顺时针移动一位，出去一个元素head移动一位；队满条件就是少存一个进行如下计算判断是否为0；
- 入栈的参数可能随时出栈导致顺序会不一致；

![](软件设计师笔记_files/133.jpg)

### 试题一

- 判断后三位排列与依次进入的顺序比对，是否可能,答案是 D;

![](软件设计师笔记_files/134.jpg)

## 8.7 广义表

- 长度3以元素判断， 深度2以括号判断
- 表头为 a ,表尾是除a以外的其他元素

- 要取b字母：head(head(tail(LS1)));

![](软件设计师笔记_files/135.jpg)

## 8.8 树与二叉树
- 度是指 结点孩子数，比如 1的度是2；树的度是 度最大的；
- 内部结点属于中间位置的结点（2，3，6）

![](软件设计师笔记_files/136.jpg)

- 完全二叉树是数字顺序大小完整；

![](软件设计师笔记_files/137.jpg)

## 8.9 树与二叉树遍历

- 相对于根的位置判断（前中后序）
- 树的前序遍历（preorder traversal）：按照先根节点后左子树再右子树的顺序遍历树中所有节点；“根-左-右”
- 树的中序遍历（inorder traversal）：按照先左子树后根节点再右子树的顺序遍历树中所有节点；“左-根-右”
- 树的后序遍历（postorder traversal）：按照先左子树后右子树再根节点的顺序遍历树中所有节点；“左-右-根”
- 层次遍历根据层次

![](软件设计师笔记_files/138.jpg)

## 8.10 反向构造二叉树
- 如果只有前、后序是不能推导出二叉树；
- 根据相对于根的位置判断（前中后序）

![](软件设计师笔记_files/139.jpg)


## 8.11 树转二叉树

- 连线法：将孩子结点连接起来，保留第一个左边孩子的连线，即可；
![](软件设计师笔记_files/140.jpg)

## 8.12 查找二叉树

![](软件设计师笔记_files/141.jpg)



## 8.13 最优二叉树

- 树路径长度：如 15到 2 长度 2
- 在二叉树中，每个节点都有一个关键字，称为该节点的“权（weight）；
- 哈夫曼编码中，节点的权重通常指该节点所代表字符的出现频率；
- 带权路径长度： 权值 * 路径长度
- 树 带权路径长度 所有累加值；

- 构造哈夫曼树，通过 选择最小权值累积得到父节点，推导出树在计算；

![](软件设计师笔记_files/142.jpg)

## 8.14 线索二叉树
- 前序遍历二叉树：ABDEH CFGI ,线索查找

![](软件设计师笔记_files/143.jpg)

## 8.15 平衡二叉树
- 左右深度 相差不能超1

![](软件设计师笔记_files/144.jpg)

## 8.16 图概念

![](软件设计师笔记_files/145.jpg)

### 图的存储 - 邻接矩阵

![](软件设计师笔记_files/146.jpg)

![](软件设计师笔记_files/147.jpg)

## 8.17 图遍历

![](软件设计师笔记_files/148.jpg)

![](软件设计师笔记_files/149.jpg)

## 8.18 图-拓扑排序
![](软件设计师笔记_files/150.jpg)

## 8.19 图的最小生成树
- 树是没有环路，n-1;
- 普里姆算法（Prim's algorithm）是一种用于求解连通加权图的最小生成树的贪心算法;
	```
	普里姆算法的过程可以描述如下：
	1.选择一个起始点 s，将其加入最小生成树的节点集合 V 中；
	2.从V中点出发集合中选取最小权重的边，将其连接并加入节点集合 V 中；
	重复步骤 2，直到最小生成树的节点集合中包含所有顶点,不能形成环；
	```

- 克鲁斯卡尔算法 （Kruskal's algorithm）是一种用于求解连通加权图的最小生成树的贪心算法;
	```
	克鲁斯卡尔算法的过程可以描述如下：
	将边按照权值从小到大进行排序；
	依次选取最小的边，并将其所连接的端点所在的连通块合并；
	重复步骤 2，直到所有的点都在同一个联通块中或者所有的边都被考虑完;
	```

![](软件设计师笔记_files/151.jpg)

#  9. 算法基础

![](软件设计师笔记_files/152.jpg)

## 9.1 算法复杂度

![](软件设计师笔记_files/153.jpg)

## 9.2 顺序查找

![](软件设计师笔记_files/158.jpg)

## 9.3 二分查找
![](软件设计师笔记_files/159.jpg)

- (1+n)/2 向下取整得中间值；
- 折半查找的比较最多次数(log2(n) + 1)次，所以时间复杂度是0(log2(n))

![](软件设计师笔记_files/160.jpg)

## 9.4 散列表

![](软件设计师笔记_files/162.jpg)

## 9.5 排序
![](软件设计师笔记_files/161.jpg)


- **直接插入排序（Straight Insertion Sorting）**的基本思想是：把n个待排序的元素看成为一个**有序表**和一个**无序表**，开始时**有序表中只包含一个元素**，**无序表中包含有n-1个元素**，排序过程中每次从**无序表中取出第一个元素**，将它插入到有序表中**从后往前比较插入**到有序表中；

![](软件设计师笔记_files/163.jpg)

- **希尔排序**是采用**分组**的思想，使用**增量(增量等于分组数（第一次是数组长度）/2,增量表示间隔多个取出值合成一个组)**进行分组，对于**每组内**的元素**进行插入排序**，随着分组数的减少，组内元素数量逐渐增多;

![](软件设计师笔记_files/164.jpg)

##  9.6 直接选择排序
- **直接选择排序** 将n个待排序的元素看成为一个有序表和一个无序表,**每次**从**无序表**中**选择最小（或最大**）的元素，**插入到有序表**的末尾，直到无序表为空;
![](软件设计师笔记_files/165.jpg)

##  9.7堆排序

![](软件设计师笔记_files/166.jpg)

### 排序 - 堆排序

![](软件设计师笔记_files/167.jpg)

- 非叶子节点和它的孩子节点比较，移动孩子节点大于父节点，交换位置；

![](软件设计师笔记_files/168.jpg)

![](软件设计师笔记_files/169.jpg)

## 9.8 冒泡排序

![](软件设计师笔记_files/170.jpg)

## 9.9 快速排序
- 双指针 递归排序

![](软件设计师笔记_files/171.jpg)

## 9.10 归并排序
![](软件设计师笔记_files/172.jpg)

## 9.11 基数排序

- 取个位 排序
- 取十位 排序
- 取百位 排序

![](软件设计师笔记_files/173.jpg)

## 9.12 排序-时间复杂度、空间复杂度（考点）

- 稳定性： 同样关键字排序后是否互换位置，是表示不稳定，否则稳定；

![](软件设计师笔记_files/174.jpg)

# 10. 程序设计语言 与 语言处理程序基础
- 考点：正规式、表达式、传值与传址

![](软件设计师笔记_files/175.jpg)

## 10.1 编译过程

- **编译型语言**指的是需要**先经过编译器**将代码翻译成机器码或字节码，再执行程序的语言；
- **解释型语言**指的是**直接将源代码解释翻译**成机器码或字节码，在执行程序的同时进行语法分析、类型检查和代码优化，需要边解释编译边执行；

![](软件设计师笔记_files/176.jpg)

## 10.2 文法
![](软件设计师笔记_files/177.jpg)

![](软件设计师笔记_files/178.jpg)

## 10.3 语法推导树
![](软件设计师笔记_files/179.jpg)

## 10.4 有限自动机
- f代表结束 因是双圈；S代表开始 起始符号；
- 比如：S输入1 得到 A;（S,1）= A;
- 一般考 ： 从开始到结束是否经过比如：1，0 （S->A-f）

![](软件设计师笔记_files/180.jpg)


## 10.5 正规式
![](软件设计师笔记_files/181.jpg)

- 无法识别:D 通过对每个选项推导判断得出；
	```
	解题思路:
	bB -> baS -> babB-> babaS或者baba 但不能生成 babba 
	```
- 对应规式:C
	```	
	解题思路：
	括号外面的* 代表 任意多个；
	所以 (ab | ba) * => 不能推导出 babba的形式
	```

![](软件设计师笔记_files/182.jpg)

## 10.6 有限自动机例题

- 答案：C, 通过 输入 0 得A->B 再输入1 得 B->A 再输入0 得C->B 再输入1 得 B->C;

![](软件设计师笔记_files/183.jpg)

## 10.7 表达式
- 答案： D
- 如果没有括号就是 先乘后在加或减；
- 有括号就按中缀表达式

![](软件设计师笔记_files/184.jpg)

## 10.8 传值与传地址

![](软件设计师笔记_files/185.jpg)

- 使用&表示取地址，使用*变量 表示指针

![](软件设计师笔记_files/186.jpg)

## 10.9 程序语言

![](软件设计师笔记_files/187.jpg)

# 11. 法律法规

- 软件公司开发一款软件，则享有该产品的**软件著作权**;
- 商业秘密必须具有未公开性、即不为公众所知、必须具有实用性、即能为权利人带来经济效益、具有保密性；

![](软件设计师笔记_files/188.jpg)

## 11.1 保护期限
![](软件设计师笔记_files/189.jpg)

## 11.2 知识产权人确定
![](软件设计师笔记_files/190.jpg)

![](软件设计师笔记_files/191.jpg)

## 11.3 侵权判定
![](软件设计师笔记_files/192.jpg)

![](软件设计师笔记_files/193.jpg)

## 11.4 标准化基础知识 - 标准的分类
![](软件设计师笔记_files/194.jpg)

![](软件设计师笔记_files/195.jpg)

# 12. 多媒体基础

## 12.1音频相关
- 大于20KHz 超声波
- 小于20Hz 次声波

![](软件设计师笔记_files/196.jpg)

## 12.2 图像
![](软件设计师笔记_files/197.jpg)

- CMY应用于印刷

![](软件设计师笔记_files/198.jpg)

## 12.3 媒体的种类
![](软件设计师笔记_files/199.jpg)

## 12.4 媒体相关计算

- 一个字节（Byte） 8 位(bit)；
- 640x480  640表示水平方向的像素 480表示垂直方向的像素
- 256色的图像，需要占多少个比特位 2^k = 258;k就是位数

![](软件设计师笔记_files/200.jpg)

- 1. 答案是：D(23); 1600x1200x24/8/1024(Kb)/1204(M) 转成M 再除以128
- 2. 答案是：C；44.1x16x2;注意单位k和bit ,小写k是1000，大写K 是1024（用于存储）；
- 3. 答案是：D; 6.4x30x10;

![](软件设计师笔记_files/202.jpg)

## 12.5 常见多媒体表准
![](软件设计师笔记_files/201.jpg)

## 12.6 数据压缩基础
![](软件设计师笔记_files/203.jpg)

## 12.7 有损压缩和无损压缩
![](软件设计师笔记_files/204.jpg)

## 12.8 软件开发模型
![](软件设计师笔记_files/205.jpg)

## 12.9 瀑布模型
- 瀑布模型只适合 需求明确、二次开发，不然有缺陷

![](软件设计师笔记_files/207.jpg)

## 12.10 其他经典模型
- 原型设计，能实现简单系统，点击操作展示

![](软件设计师笔记_files/206.jpg)

## 12.11增量模型与螺旋模型
- 优先原型模型 然后螺旋模型

![](软件设计师笔记_files/208.jpg)

## 12.12其他经典模型-V型 与喷泉模型与RAD
- V模型 注重测试
- 喷泉模型 面向对象

![](软件设计师笔记_files/209.jpg)

## 12.13 构件组装模型
- 提高可靠性和复用性

![](软件设计师笔记_files/211.jpg)

## 12.14 统一过程模型
- 别名：UP、RUP

![](软件设计师笔记_files/212.jpg)

## 12.15 敏捷开发模型
- 小项目设计开发

![](软件设计师笔记_files/210.jpg)

#  13. 信息系统开发方法
![](软件设计师笔记_files/213.jpg)

#  14. 需求开发
![](软件设计师笔记_files/214.jpg)

# 15. 结构化设计
## 15.1 基本原则
- 扇入是箭头指向自己的，扇出是指出去的

![](软件设计师笔记_files/215.jpg)
## 15.2 内聚与耦合
![](软件设计师笔记_files/216.jpg)

## 15.3 系统结构、模块结构
![](软件设计师笔记_files/218.jpg)

# 16. 软件工程

## 16.1 软件测试 - 原则与类型
![](软件设计师笔记_files/217.jpg)

## 16.2 软件测试 - 测试用例设计
![](软件设计师笔记_files/219.jpg)

## 16.3 测试阶段
![](软件设计师笔记_files/220.jpg)

## 16.4 McCabe复杂度（考点)
![](软件设计师笔记_files/221.jpg)

## 16.5 系统运行与维护
![](软件设计师笔记_files/223.jpg)

## 16.6 软件过程改进 - CMMI
![](软件设计师笔记_files/222.jpg)

# 17. 系统开发基础

## 17.1 项目管理
![](软件设计师笔记_files/224.jpg)

- Grantt图不能清晰的描述各任务之间的依赖关系
- 计算右侧的值 加 箭头上的值 得到下个右侧的值并取分支中最大的值，再反向推理出结果

![](软件设计师笔记_files/225.jpg)

## 17.2 项目管理 - 风险
![](软件设计师笔记_files/226.jpg)

# 18. 需求工程

## 18.1 需求开发
- 对象：对象是基于类定义的实体，包含了变量和方法。所有的对象都需要通过类来创建，每个对象都有特定的状态（属性）和行为（方法），它们可以执行各种操作并与其他对象进行交互；
- 泛化：指的是一个类（派生类）继承了另一个类（基类）的所有属性和方法，并可以在此基础上进一步添加或修改属性和方法的过程。这个过程也被称为“子类继承父类”的操作；
- 消息：异步通信的方式

![](软件设计师笔记_files/227.jpg)

## 18.2 设计原则
- 里氏替换原则：关键在于子类继承父类时，不应该影响基类已经定义好的行为，只能扩展或增加新的行为。如果子类改变了基类原有的行为，或者违反了基类已有的约束，“扩展”就变成了“破坏”，这样会导致程序出现问题；

![](软件设计师笔记_files/228.jpg)

## 18.3 UML 
![](软件设计师笔记_files/230.jpg)

# 19. 面向对象设计
##  19.1 设计模式的概念
![](软件设计师笔记_files/229.jpg)

## 19.2 设计模式的分类
![](软件设计师笔记_files/231.jpg)

## 19.3 创建型模式
![](软件设计师笔记_files/232.jpg)

## 19.4 结构型模式
![](软件设计师笔记_files/233.jpg)

## 19.5 行为型模式
![](软件设计师笔记_files/234.jpg)

![](软件设计师笔记_files/235.jpg)

# 20. 数据流图(考点)
## 20.1 内容提要

![](软件设计师笔记_files/236.jpg)

## 20.2 数据流图的基本概念
![](软件设计师笔记_files/237.jpg)

![](软件设计师笔记_files/238.jpg)

## 20.3 数据流图
![](软件设计师笔记_files/239.jpg)


## 20.4 数据字典
![](软件设计师笔记_files/241.jpg)

## 20.5 数据流图平衡原则（考点）

- 子图内平衡是既有输入又有输出

![](软件设计师笔记_files/242.jpg)

- 顶层数据图与 0 层数据流图的一致性

![](软件设计师笔记_files/240.jpg)

## 20.6 答题技巧

![](软件设计师笔记_files/243.jpg)

### 试题一

![](软件设计师笔记_files/246.jpg)

![](软件设计师笔记_files/245.jpg)

![](软件设计师笔记_files/247.jpg)

#### 答案
![](软件设计师笔记_files/244.jpg)

![](软件设计师笔记_files/248.jpg)

![](软件设计师笔记_files/249.jpg)

### 试题 二
![](软件设计师笔记_files/250.jpg)

![](软件设计师笔记_files/251.jpg)

![](软件设计师笔记_files/252.jpg)

#### 答案
![](软件设计师笔记_files/253.jpg)

- P1 交易信息查询
- P2 信用卡客户信息管理
- P3 信用卡激活
- P4 信用卡申请

![](软件设计师笔记_files/255.jpg)

# 21. 数据库设计
![](软件设计师笔记_files/254.jpg)

## 21.1 ER模型

![](软件设计师笔记_files/256.jpg)

![](软件设计师笔记_files/257.jpg)

## 试题一
![](软件设计师笔记_files/258.jpg)

![](软件设计师笔记_files/263.jpg)

![](软件设计师笔记_files/260.jpg)
- 1. （1）1:n (2) m:1 (3) n:1
- 2. 员工对 权限 是 n:1, 一个权限可以分配给多个用户；
- 3. (4) 员工号 部门号 （5）客房号 （6）身份证号 （7）岗位 （8）客房号 身份证号
- 4. 重复存储数据造成数据冗余，可以减少数据连接操作查询效率高些；

![](软件设计师笔记_files/261.jpg)

## 试题二

![](软件设计师笔记_files/259.jpg)

![](软件设计师笔记_files/262.jpg)

![](软件设计师笔记_files/267.jpg)

- 2. （a）商场编号 (外键) （b）部门编号 （外键） (c) 员工编号
- 3.  员工编号 、 紧急联系人姓名、紧急联系人电话 ; 员工 对 紧急联系人(n:1) 

![](软件设计师笔记_files/264.jpg)

![](软件设计师笔记_files/265.jpg)

![](软件设计师笔记_files/266.jpg)

# 22. UML

## 22.1 用例图

![](软件设计师笔记_files/268.jpg)
## 22.2 类图与对象图
![](软件设计师笔记_files/269.jpg)

![](软件设计师笔记_files/270.jpg)

![](软件设计师笔记_files/271.jpg)

## 22.3 顺序图
![](软件设计师笔记_files/272.jpg)

## 22.4 活动图

- 注意：粗的横线表示产生多少并行的线程操作

![](软件设计师笔记_files/273.jpg)

![](软件设计师笔记_files/274.jpg)

## 22.5 状态图
![](软件设计师笔记_files/275.jpg)

## 22.6 通信图
![](软件设计师笔记_files/276.jpg)


### 试题一

![](软件设计师笔记_files/277.jpg)

![](软件设计师笔记_files/280.jpg)

- 最短事件序列： 关闭-> 任意键 -> 歌曲待选 -> 选择歌曲 -> 播放

![](软件设计师笔记_files/278.jpg)

- 缺少一条关联： 音轨的 自关联

![](软件设计师笔记_files/279.jpg)


### 试题二

![](软件设计师笔记_files/281.jpg)

![](软件设计师笔记_files/282.jpg)

![](软件设计师笔记_files/283.jpg)

- 答案：
- 使用的设计模式：状态设计模式
- 具备属性：CLevel 对象
- travel方法具有：需要 计算飞行里程数

![](软件设计师笔记_files/285.jpg)

![](软件设计师笔记_files/284.jpg)

# 23. 数据结构与算法

![](软件设计师笔记_files/286.jpg)

## 23.1 分治法

分治法是将问题**分成多个子问题**，递归地**解决每个子问题**，然后再将它们的解**汇总起来得到原问题的解**；

这种算法设计的思想可以表达为以下三个步骤：

1. 将原问题分成若干个规模较小且相互**的子问题；
2. 解决这些子问题，递归地求解各子问题的解；
3. 合并子问题的解成原问题的解。

![](软件设计师笔记_files/287.jpg)
### 23.1.1 递归
![](软件设计师笔记_files/288.jpg)

### 23.1.2 二分查找
![](软件设计师笔记_files/289.jpg)

## 23.2 回溯法
- 迷宫方式

![](软件设计师笔记_files/290.jpg)


## 23.3贪心法
- 每次选最好，不定是最优解

![](软件设计师笔记_files/291.jpg)

## 23.4 动态规划
![](软件设计师笔记_files/292.jpg)

### 试题一

![](软件设计师笔记_files/293.jpg)

![](软件设计师笔记_files/294.jpg)

![](软件设计师笔记_files/295.jpg)

![](软件设计师笔记_files/297.jpg)

![](软件设计师笔记_files/298.jpg)

### 试题二
![](软件设计师笔记_files/296.jpg)

![](软件设计师笔记_files/299.jpg)

![](软件设计师笔记_files/300.jpg)

![](软件设计师笔记_files/301.jpg)



# 24. 面向对象

![](软件设计师笔记_files/302.jpg)

![](软件设计师笔记_files/303.jpg)

![](软件设计师笔记_files/304.jpg)

![](软件设计师笔记_files/305.jpg)

![](软件设计师笔记_files/306.jpg)


![](软件设计师笔记_files/307.jpg)

## 24.1 Java
![](软件设计师笔记_files/308.jpg)

![](软件设计师笔记_files/309.jpg)

![](软件设计师笔记_files/310.jpg)

![](软件设计师笔记_files/311.jpg)

### 试题 一
![](软件设计师笔记_files/313.jpg)


![](软件设计师笔记_files/314.jpg)
![](软件设计师笔记_files/315.jpg)
![](软件设计师笔记_files/312.jpg)

![](软件设计师笔记_files/316.jpg)

### 试题二

![image-20230414084250092](软件设计师笔记_files\image-20230414084250092.png)

![image-20230414084813988](软件设计师笔记_files\image-20230414084813988.png)

![image-20230414084905581](软件设计师笔记_files\image-20230414084905581.png)

![image-20230414085303780](软件设计师笔记_files\image-20230414085303780.png)

#### 答案

![image-20230414085347845](软件设计师笔记_files\image-20230414085347845.png)